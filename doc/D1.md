# ğŸ““ Project Log: Day 1 - Foundation & Data Pipeline

---

## ğŸ¯ 1. What We Accomplished

We built the **foundation** for our financial analysis application. Three major achievements:

1. **Set Up a Professional Environment** ğŸ› ï¸

   * Created a **containerized development environment** using **Docker** for the database.
   * Ensures isolation & consistency across all environments.

2. **Built an Automated Data Pipeline** ğŸ”„

   * Wrote **Python code** to automatically fetch **financial statements** (income, balance sheet, cash flow) and **historical price data** for any stock ticker.

3. **Created a Web API** ğŸŒ

   * Exposed the pipeline via **FastAPI**.
   * Other apps (and AI agents) can now easily request and consume data.

---

## âš™ï¸ 2. How We Built It (File-by-File Breakdown)

### ğŸ“‚ `docker-compose.yml`

* **What:** Instruction manual for Docker (PostgreSQL database with PGVector).
* **How:** Launches `financial_db` container, sets up user/password from `.env`, maps port for app access.

### ğŸ“‚ `.env`

* **What:** Stores **secrets & configs** (API keys, DB passwords).
* **Why separate:** Never committed to Git â†’ ensures **security** + allows different configs for dev/prod.

### ğŸ“‚ `src/core/config.py`

* **What:** Loads `.env` variables into the app.
* **How:** Uses **pydantic-settings** â†’ validates required vars â†’ provides a clean `settings` object.

### ğŸ“‚ `src/db/session.py` & `models.py`

* **models.py:** Defines DB tables using SQLAlchemy ORM (e.g., `FinancialStatement` â†’ `financial_statements` table).
* **session.py:** Manages **DB connection** (engine + `get_db` function for API requests).

### ğŸ“‚ `src/services/financial_data.py`

* **What:** Core business logic (the brain of the pipeline).
* **How:**

  * `fetch_and_store_statements`: Downloads financial data via **yfinance**, processes/cleans it, stores in DB.
  * `get_ohlcv`: Fetches historical price data.

### ğŸ“‚ `src/api/`

* **What:** The **front door** of the application (API endpoints).
* **How:**

  * `data.py` defines endpoints like `/fetch/{ticker}`.
  * Routes requests to service layer (`financial_data.py`).
  * Keeps API layer **thin & clean**.

### ğŸ“‚ `src/main.py`

* **What:** Entry point of the app.
* **How:** Creates **FastAPI app**, initializes DB tables (if missing), and includes routers.

---

## ğŸ¤” 3. Why We Did It This Way (The Rationale)

### ğŸ³ Why use Docker for the database?

* **Consistency:** Same behavior on any machine (local, teammate, production). No "works on my machine" issues.
* **Isolation:** DB & data stay separate from OS. Easy to clean/manage/remove.

### ğŸ“‚ Why this folder structure? (Separation of Concerns)

* **Maintainability:** API, business logic, DB code separated â†’ easier to locate & modify.
* **Scalability:** New services or API versions can be added without breaking existing code.

### âš¡ Why have a "Service Layer" (`financial_data.py`)?

* **Decoupling:** API endpoints donâ€™t care how data is fetched/stored.
* Swap out data provider (e.g., yfinance â†’ Alpha Vantage) with **only service changes**, leaving API untouched.

### ğŸŒ Why expose data via an API?

* **Modularity:** Future AI agents just call HTTP (`POST /api/v1/data/fetch/AAPL`).
* **Universality:** API is a standard, simple way for components to communicate.

---
